
%
%  $Description: Author guidelines and sample document in LaTeX 2.09$ 
%
%  $Author: ienne $
%  $Date: 1995/09/15 15:20:59 $
%  $Revision: 1.4 $
%

\documentclass[times, 10pt,twocolumn]{article}
\usepackage{latex8}
\usepackage{times}
\usepackage{epsfig}

%\documentstyle[times,art10,twocolumn,latex8]{article}

%------------------------------------------------------------------------- 
% take the % away on next line to produce the final camera-ready version 
\pagestyle{empty}

%------------------------------------------------------------------------- 
\begin{document}

\title{Metamodels for System Architecture - Coping with Inconsistency}

\author{Peter Henderson\\
University of Southampton\\ Electronics and Computer Science \\ SO17 1BJ, UK\\ p.henderson@ecs.soton.ac.uk\\
% For a paper whose authors are all at the same institution, 
% omit the following lines up until the closing ``}''.
% Additional authors and addresses can be added with ``\and'', 
% just like the second author.
\and
Matthew J. Henderson\\
Berea College\\
Mathematics and Computer Science \\ 
Berea, KY. 40404, USA \\ 
Matthew\_Henderson@berea.edu\\
}


\maketitle
\thispagestyle{empty}

\begin{abstract}
Very large systems have an architecture that is designed to allow them to evolve through a long life. Such systems are developed by first making a model of their architecture. This model constitutes a formal architecture description. The model is governed by a specialised metamodel whose rules determine the consistency and completeness of the description. During development of a system, it is quite normal for the architecture description to be both incomplete and inconsistent. The architects strive to produce a complete description and to eliminate the inconsistencies. By means of an example, we show how architecture descriptions formalised in relational algebra can aid this iterative process of development and how the model and the metamodel must co-evolve. We describe a design tool that we have developed to support this process of co-evolution.
\end{abstract}



%------------------------------------------------------------------------- 
\Section{Introduction}

\noindent Very large systems have an architecture that is designed to allow them to evolve through a long life. For us, large systems are those that require many engineers to collaborate over an extended system lifetime. 

One way in which such systems are developed is by first making a model of their architecture. This model constitutes a formal  architecture description. The language chosen for the architecture description is usually a mixture of diagrams (in UML or SysML, for example) and lots of documentation of requirements and interfaces to components that are to be procured or built.

The more formal the architecture description, the more likely we are to be able to determine incompletenesses and inconsistencies at an early stage. A formal architecture model is governed by a specialised metamodel whose rules determine the consistency and completeness of the description. During development of  a system, it is quite normal for the architecture  description to be both incomplete and inconsistent.  The architects strive to produce a complete  description and to eliminate the inconsistencies. 

By  means of an example, we show how architecture descriptions formalised in relational algebra can aid this iterative process of architecture development and how the  model and the specialised metamodel must co-evolve. 

We describe a  design tool that we have developed to support this  process of co-evolution. This tool will calculate inconsistencies within the model. It does not insist on the model always being consistent. Rather it produces reports of inconsistencies that should eventually be removed. This mechanism supports both incremental and collaborative working, essential to the development of large systems by teams of engineers.
%------------------------------------------------------------------------- 
\Section{System Architecture Models}

\noindent System Architects start from a mixture of user requirements, system requirements and legacy components and devise an architecture that meets the requirements while making effective use of existing components. They will describe the architecture using a mixture of diagrams and natural language that is effective as a means of communication among them and their customers \cite{Gokhale,Henderson1,Henderson2, Kruchten,Maier,Rozanski,Shaw,Shaw1}. It seems that diagrams are most effective at indexing a description, that a natural language description is an essential adjunct to that and that a judicious use of formal language can complement these necessary aspects of presentation.

The language we choose to describe a proposed architecture needs to be sufficiently formal that some consistency checking can be done but not so detailed that the work of describing the architecture is tantamount to building the whole system.

Hence many system architects use diagrammatic notations such as those that constitute UML and SysML and specialise them to their specific needs. This specialisation can be represented by a {\em specialised metamodel} which enumerates the entities that will be used to describe the architecture and defines the constraints that instances of these entities must obey. 
\begin{figure}[h]
  \centering
   {\epsfig{file = figures/mcfigure1.eps, width = 7.0 cm}}
   \caption{A class diagram showing the client/server relationships
between components in a system. Arrows point from client to server. This will be part of a much larger diagram. An architecture for a large system will include many such diagrams.}
\end{figure}
The architecture development process that we advocate comprises an iterative co-evolution of the architecture model and the specialised metamodel. To be more specific about the way we are using the terms model and metamodel in this paper, Figures 1 and 2 show snippets of an architecture model comprising a class diagram and a sequence diagram, while Figure 3 shows the metamodel that will be used to specify the constraints among the entities appearing in Figures 1 and 2.


\Section{Metamodels and Relational Algebra}
\noindent We will use a relational model to develop the formal aspects of our architecture description, as many others have done before us \cite{Crocopat,Crocopat2,Holt,Alloy}. 

The example we have chosen to illustrate this method is very simple. It presumes that the system we are going to build can be considered to be made of Components that pass Messages to each other. The architecture will thus comprise an enumeration of the Components and of the Messages they can receive over their interfaces. Messages will invoke Operations on the Components.

To be able to adequately validate the architecture (which we presume may comprise hundreds of Components) we will introduce redundancy in its description. We will say which Components are clients, using which others as servers. We will also enumerate a range of scenarios where particular behaviours of the system are achieved by specific sequences of messages between components.
\begin{figure}[h]
  \centering
   {\epsfig{file = figures/mcfigure2.eps, width = 7.0 cm}}
   \caption{A sequence diagram that shows part of one scenario. The system would be described by many such scenarios. The message labelled op1, from C2 to C1, is inconsistent with the class diagram in Figure 1.}
\end{figure}
The architecture description will comprise many class diagrams such as that shown in Figure 1 and many sequence diagrams such as that shown in Figure 2. They conform to the metamodel shown in Figure 3 in a way that we will now formalise.

The snippet of a class diagram in Figure 1 has three entities of type Component (labelled C1, C2 and C3). There are also three Associations between these Components which we have not labelled. Each Association has a source and a target. These properties are captured by the relations {\small\verb$source(Association, Component)$} and {\small\verb$target(Association, Component)$} 
\begin{figure}[h]
  \centering
   {\epsfig{file = figures/mcfigure3.eps, width = 7.0 cm}}
   \caption{A class diagram of the specialised metamodel to which the class and sequence diagrams in Figures 1 and 2 should conform. This diagram is supplemented by additional constraints given in terms of the relations named here.}
\end{figure}

The snippet of sequence diagram shown in Figure 2 shows three Messages, each labelled by an Operation. Each Message has a sender which is a Component, a receiver which is a Component and an Operation which is the method it is invoking on the Component receiving the Message. These properties are captured by the relations 
{\small\verb$sender(Message, Component)$}, 
{\small\verb$receiver(Message, Component)$} and 
{\small\verb$method(Message, Operation)$}.

It is presumed that every Component supplies a set of Operations that can be invoked by Messages. This property of a Component is captured by the relation {\small\verb$operations(Component, Operation)$}. 

Of course, this is a specific metamodel, what we have chosen to call a specialised metamodel, developed to be able to describe a certain architecture at a certain level of detail. Other specialised metamodels will be required for other applications. It is therefore essential that evolving the metamodel should be as straightforward as evolving the model itself.


\Section{Consistency }
\noindent The reason we are concerned with consistency is that, for large systems, many components and many scenarios will be defined and it will improve the quality of the description if these individual descriptions can be made consistent. Others have approached consistency checking in ways that we have adapted to our purpose here \cite{Gokhale,Crocopat,Crocopat2,Chang,Chang2,Dekel,Holt,Shen}, each choosing to look at specific aspects of consistency. We have done that too.

For example, in the specialised metamodel that we have used to illustrate our method, it would be reasonable to insist that every message that is sent goes from a client to a server that are in the client/server relationship to each other. That is, there is an Association in a class diagram that corresponds to every Message instance.

Rather than check that consistency, we construct the following relation
\begin{small}
\begin{verbatim}
   ~sender.receiver - ~source.target
\end{verbatim}
\end{small}
This relation denotes the pairs of components that have messages between them but which do not have corresponding client/server associations. In the data represented in Figures 1 and 2, the only such component pair is (C2,C1).

This relational algebra expression uses two operators {\small\verb$~$} which is transpose (or invert, for a binary relation) and {\small\verb$.$} which is natural join. Thus {\small\verb$~sender.receiver$} denotes those pairs of components that have messages between them and {\small\verb$~source.target$} those that have client/server associations.

If we specialise our metamodel to require that messages can only be between associated components, then the relation we have constructed above represents a set of inconsistencies. 

We can specialise the metamodel in any way we wish. For example, we might want to insist that the operations that label the messages on sequence diagrams are actually valid operations of the receiving component. This can be determined by constructing the following relation
\begin{small}
\begin{verbatim}
   method - receiver.operations
\end{verbatim}
\end{small}
and expecting that the architects will strive to ensure that it is eventually empty.

In this expression {\small\verb$receiver.operations$} denotes pairs of Messages and Operations where a message is paired with operations that are allowed for its receiver, so 
{\small\verb$method-receiver.operations$} 
is those methods that are used but should not be.

Note that by constructing relations in this way we are applying the consistency check to the {\em whole architecture}. Rather than prevent the insertion of inconsistencies during architecture development, we allow the architects to develop through periods of inconsistency by enabling them to check which inconsistencies have been introduced by recent changes. We will describe how this supports iterative and collaborative working in the next section.

As a final example of the types of specialisation we might apply to a metamodel such as that in Figure 3, consider the architects' role in preparing their design for testing. 

We might expect that in a completed architecture description which uses the entities of this metamodel to capture the architecture on a combination of class and sequence diagrams, that every Component and every Operation should be used in at least one sequence diagram.

Consider {\small\verb$Component-ran(receiver)$}. This is precisely the set of Components that do not appear as receivers in any sequence diagram.  Similarly {\small\verb$operations-~receiver.method$} is the relation between Components and Operations which enumerates all the operations that are not used in any sequence diagram.

In practice, we may wish to construct more complex relations than those that we have exemplified here and for which we will require more expressive forms than the simple relational operators used in this section. In the next section we describe how we have based our tooling on the relational algebra in Alloy, which has a general comprehension construct which we occasionally need to use. But the discipline afforded by staying close to an algebraic form, as we have done here, seems to lead to cleaner metamodels.



\Section{Support Tools}
\noindent To be able to experiment with different metamodels, and different architecture descriptions within these metamodels, we have made a simple ``database calculator" that supports the editing of data in relational tables and the calculation of derived relations.

Originally we did our experimentation in Alloy and still do the initial development of new metamodels in Alloy \cite{Alloy}, because of its ability to construct examples and counterexamples to general conjectures about the metamodel.

We built our own tool for purely pragmatic reasons; to be able to hold the data in a database; to be able to extract data from other tools using XMI; to be able to produce professional reports of architectures in development. 

The tool can be configured with a new metamodel by writing scripts that construct derived tables from base tables. The derived tables are defined by the relational algebra expressions that represent inconsistencies in the data. The idea is that the architect makes some changes and then explores the derived tables to see what inconsistencies have been introduced or removed. Thus the process of architecture description is iterative.

Iterative changes can be applied to the metamodel by editing the scripts that recompute derived tables. This recomputation can be lazy - only being carried out when necessary, such as when the architect actually inspects a derived table and when there is genuinely new data which affects that table.

Cooperative working is supported by our tool by the simple means of allowing architects to work on independent copies of the data and then to merge these independently evolved copies. Merge comprises no more than taking the union of base tables and then recomputing the derived tables. Inconsistent updates simply appear as inconsistencies in the merged description. Untouched parts of the description survive unscathed. Deletions only take effect if both independently evolved copies have the same item deleted.

This way of working has proved very effective. We have various metamodels for different UML and SysML based metamodels similar to the one described here %\cite{Henderson4}
. We also have metamodels for generating bespoke documentation from architecture descriptions \cite{Henderson3}. We are developing metamodels to support modular reasoning such as that required to make effective presentations of safety cases and other accreditation aspects of architecture \cite{Rushby}.

\Section{Conclusions}
\noindent We have described a method of developing architecture descriptions based on giving a sufficiently precise metamodel that consistency can be checked during architecture development.

Rather than insist that the architecture description is kept consistent at all times, we advocate a method of iterative and cooperative development that allows the description to be periodically inconsistent.

We have shown how the metamodel can be captured formally in relational algebra and argued that this method is particularly appropriate to this style of development, not least of all because it encourages the architects to embrace the whole architecture at all times and to keep in mind how far from internal consistency the description may have drifted.

The method has been applied to software modelling. It also seems appropriate to other domains. We have in hand experiments with metamodels for documentation, for reasoning and have an ambition to extend the method to a broader range of systems, in particular those that have physical as well as logical structure.

%------------------------------------------------------------------------- 
\nocite{Shen,Rushby,Chang2}
\bibliographystyle{latex8}
\bibliography{metaconsist}

\end{document}

