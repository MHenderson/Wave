\documentclass[a4paper,twoside]{article}

\usepackage{epsfig}
\usepackage{subfigure}
\usepackage{calc}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{multicol}
\usepackage{pslatex}
\usepackage{apalike}
\usepackage{fancyhdr}
\usepackage{insticc}
\usepackage[small]{caption}


\begin{document}
\onecolumn \maketitle \normalsize \vfill

\section{\uppercase{Introduction}}
\label{sec:introduction}

\noindent Systems Architecture is that branch of Information System design that determines the overall structure and behaviour of a system to be built. Typically, an architecture is captured as an evolving set of diagrams and specifications, put together by a team of System Architects and iteratively refined over a period of consultation with the customers for the solution. The extent to which the architecture represents a buildable or procurable solution depends a great deal on the consistency and completeness of the architecture description and the extent to which it can be validated prior to commitment to procure.

Validation of the architecture as early as possible in the process of development is important. This aspect of System Engineering is not well supported by tools. In this paper we advocate an approach to architecture description which lends itself to validation throughout architecture development.

The key idea is that the architects define a metamodel that enumerates the types of entities they are going to use in their description, along with the relationships between these entities. For example, they might choose to describe their architecture in terms of components or messages or interfaces. 

As part of the metamodel, the architects will also specify constraints which a {\em valid} description must satisfy. Validation of the architecture description comprises checking the extent to which these constraints are satisfied. We have developed tools to support this approach.

An architecture description for a large system will need to be at a high level of abstraction and will be subject to incremental development. These attributes both present challenges for architecture validation. Moreover, the specialised metamodel used to define validation, will itself develop incrementally, in parallel with the architecture description itself, which presents a further challenge. The whole-architecture approach that we describe addresses these challenges.

The paper begins with a discussion of the problem area. It then presents an example of a style of architecture description which is quite commonly adopted - Components and Interfaces in UML. It then describes a specialised metamodel for this style of description,  including the types of consistency that the architects may wish to achieve. Finally the tools that we have developed to support this approach are described.

\section{\uppercase{Background}}
\label{sec:background}

\noindent In Systems Engineering, in particular for software intensive systems, the design of a solution is normally developed around a system architecture.The description of this architecture is a shared model around which the architects work to understand the customer requirements and how these can be mapped on to programs and databases to realise a solution. 

The field of architecture description is now relatively mature \cite{Kruchten,Shaw1,Maier,Henderson2,Rozanski,Shaw}. Specific approaches to architecture description have, in many respects, found their way into standard representations such as UML \cite{UML} and SysML \cite{SysML}, so it is now quite common to find these notations in use in industrial projects. There are other approaches that look promising \cite{Holt,Hadar,Gokhale,Dekel} but these are ideas that are easily adopted as specialisations of the standard notations. The Model Driven Architecture approach to system development \cite{MDA} effectively assumes that a notation needs to be open to extension and specialisation.

The need for architects to share a model, and for this model to evolve, immediately introduces the realisation that for most of its life the architecture description will be incomplete and probably inconsistent. Looking for inconsistencies in the architecture description is the principal means of validating it early in its life \cite{Crocopat2,Chang,Koo,Hadar,Henderson3,Henderson4}. The research reported here builds on those ideas.

In particular, like others, we take an approach to architecture description based on relational models \cite{Holt,Crocopat2}. We capture the details of an architectural description in UML or SysML, but support this with a precise metamodel that has been expressed relationally. This means that we can capture the consistency constraints very precisely in relational algebra \cite{Date,Crocopat} and formally validate the metamodel as we develop the architecture description. In practice, the formal relational algebra that we have used is that embedded in the formal modelling language Alloy \cite{Alloy}. This has pragmatic advantages that we will address later. 

The consequences for the research reported here are that we have a method of capturing an architectural metamodel in Alloy, of capturing an architecture according to this metamodel in UML and a means of presenting that architecture to Alloy for consistency checking throughout its life. We claim that this method (and our tools) supports both incremental development and collaborative working, for which we will give evidence in a later section. In order to describe the method, we begin with an example of architecture description based on UML Component diagrams. 


\section{\uppercase{Components and Interfaces}}

\noindent Many large systems benefit from having their architecture described using Component diagrams in UML. These diagrams use 
%
\begin{figure}[!h]
  \centering
   {\epsfig{file = figures/figure1.eps, width = 7.0 cm}}
  \caption{A consistent structure}
  \label{fig:fig1}
\end{figure}
%
Components to denote units of functionality and they use Interfaces to show how these units are plugged together to form assemblies with greater functionality. Components often denote quite substantial units of functionality.

Figure~\ref{fig:fig1} shows a (simplified) Component diagram in which we see that Component $P$ has nested within it two further components $A$ and $B$. Strictly speaking, because it shows nesting, this is actually an example of a UML 2.0 Composite Structure diagram, where that diagram has been specialised to show nesting of Components.

The interfaces in Figure~\ref{fig:fig1} are shown by the ball-and-socket notation. For example Component $A$ shows that it {\em requires} an Interface $IB$ by its use of a socket with that label. Fortunately, also nested within Component $P$ is a Component $B$ which {\em supplies} such an interface, shown by the ball with that label. Normally, in a UML 2.0 diagram, this association between {\em requires} and {\em supplies} would be shown by an arrow from one to the other. Rather than do that here, since our diagrams are so simple, we have relied upon the reader's ability to associate the two Components through their reference to an Interface by name.

We see that all the components in Figure~\ref{fig:fig1}  supply or require interfaces. Normally, a component will both require and supply many interfaces, not just one of each as shown in this simple example. We say that the example in Figure~\ref{fig:fig1} is consistent because all of the interface requirements are satisfied. The fact that Component $B$ requires Interface $IC$ is satisfied by this being brought to the outside and shown as a required interface on the parent $P$. Similarly, that Component $P$ supplies Interface $IA$ is satisfied by the fact that it contains a nested Component $A$ which is the source of this interface.

These rules of consistency are not part of UML as such, but are specialised by the Systems Architect using this notation to meet their intentions. This is part of what we will describe later as the use of a %
\begin{figure}[!h]
  \centering
   {\epsfig{file = figures/figure2.eps, width = 7.0 cm}}
  \caption{An inconsistent structure}
  \label{fig:fig2}
\end{figure}
%
specialised metamodel. We ask the reader to bear with us until then, when we argue that these specific consistency constraints are reasonable.

In contrast Figure~\ref{fig:fig2} shows an inconsistent Component diagram. This time Component $Q$ contains Components $A$ and $D$ which leads to some mismatches. Most obviously, we see that Component $A$, in this context, does not have its requirement for Interface $IB$ satisfied, because there is no sibling that supplies that interface, nor has it been brought to the outside and made a required interface of the parent $Q$. We refer to this missing connection as {\em dangling requires}. We say that, within Component $Q$ there is a dangling-requirement for Interface $IB$.

Moreover Figure~\ref{fig:fig2} shows an example of what we will call a {\em dangling supplies}. This is because Component $Q$ supplies Interface $IX$ but that is not one of the available interfaces supplied by one of its nested members. Again, note that this is a consistency constraint which is specialised from the metamodel that we are adopting and this will be explained later. Further, while we say that Component $Q$ has a dangling-supplies of Interface $IX$, we do not consider the unused Interface $ID$ of Component $D$ to be a problem (again, a decision of the metamodel) 

So far, what we have presented is an example of the type of Architecture Description that we advocate. It is based on a metamodel that we will introduce in a little while. The metamodel determines what types of entities will be described (here Components and Interfaces) and the consistency constraints that they must satisfy. In general, the metamodel will be defined by the Systems Architects for the specific system being designed and may use quite different entities and/or consistency constraints. We will discuss other metamodels later but first we will show how this one is formalised.

\section{\uppercase{Formalisation}}
\label{sec:formalisation}
\noindent We use the formal modelling language Alloy \cite{Alloy} because it has a built-in consistency checker based on a SAT-solver and is known to be very efficient. The basic modelling paradigm of Alloy (relational algebra) is ideally suited to capture the metamodels that we are using and to support the metamodel-specific tools that we have developed.We will introduce Alloy here and describe it only in as much detail as we require to illustrate our use of it.

Alloy uses a very precise OO class notation to define entities and the relationships between them. For example 
\begin{small}
\begin{verbatim}
  sig Component{
    contains: set Component,
    requires, supplies: set Interface
  }\end{verbatim}
\end{small}
defines a class of entities of type Component. Alloy uses {\small\verb$sig$} (from signature) to denote classes of entities. This {\small\verb$sig$} also introduces three (binary) relations, respectively {\small\verb$contains$}, {\small\verb$requires$} and {\small\verb$supplies$}. The domain of each of these relations is Component. The range of {\small\verb$contains$} is Component while the range of {\small\verb$requires$} and {\small\verb$supplies$} is another class Interface, defined elsewhere.

In fact, for the purposes of this paper, it is sufficient to define Interface in Alloy as 
\begin{small}
\begin{verbatim}
  sig Interface{}
\end{verbatim}
\end{small}
since we do not require any specific properties of Interfaces in these examples. The introduction of classes of entities in this way in Alloy allows its constraint solver to introduce specific instances of these entities in order to construct examples or counter-examples of properties we will formulate.

Figure~\ref{fig:fig3} shows the entities and relations introduced by these signatures. It is the beginning of the metamodel against which we are developing our system descriptions. The rest of the metamodel comprises the consistency constraints among these entities. Of course, this simple metamodel also needs to be extended with additional entities to be sufficiently useful in practice and these entities in turn will require further constraints. This is the topic of the next section.

The principal datatype in Alloy logic is the multi-relation, that is - a set of tuples. This is used to represent virtually everything. Sets are just unary-relations and entities are just singleton sets. This introduces an economy of notation which sets Alloy apart from other formal notations in an interesting way. 

Alloy thus has a range of operations on (multi-) relations, principally join and comprehension, which we will introduce by example.

%
\begin{figure}[!h]
  \centering
   {\epsfig{file = figures/figure3.eps, width = 7.0 cm}}
  \caption{A metamodel}
  \label{fig:fig3}
\end{figure}
%
The (natural) join operator is denoted by a dot and forms the relational composition of its operands. Thus, for example
\begin{small}
\begin{verbatim}
  contains.requires
\end{verbatim}
\end{small}
denotes a binary relation formed from the composition (join) of two existing binary relations. {\small\verb$contains.requires$} denotes the relationship between Components and Interfaces 
that is (Component){\small\verb$c$} 
``contains a Component that requires" 
(Interface){\small\verb$i$} . 

This join is the basic operator in Alloy and doubles up in formulae as the operator for both selecting attributes of objects and for indexing collections. However, sometimes we need to deal with entities directly and for this Alloy uses a fairly conventional comprehension notation. For example
\begin{small}
\begin{verbatim}
  {p:Component, c:Component, i:Interface|
      p->c in contains and c->i in requires}
\end{verbatim}
\end{small}
is one way to construct the ternary relation that is like {\small\verb$contains.requires$} but which retains the column on which the relations are joined. Note that Alloy uses {\small\verb$x->y$} to denote a two-tuple and {\small\verb$x->y->z$} to denote a triple. So {\small\verb$p->c in contains$} is to be read ``the two tuple {\small\verb$p->c$} is in the relation {\small\verb$contains$}". 

It is worth noting at this point that this focus on the whole-relation that Alloy encourages, leads to a holistic approach to the analysis of Systems Architectures, which is something we will return to in the section on Pragmatics. It is almost always the case that our relations are many-to-many. Where we have relations of greater arity in the metamodel we will normally show projections of these on the diagram, but this is not needed in this paper. The relational algebraic approach affords a way of ``reading-off" the diagram the derived relations that will be constructed as consistency rules in our metamodel.

The way in which one uses Alloy, as we will illustrate in the next section, is to construct predicates and challenge Alloy to construct either an example or a counter-example of the predicates. Alloy does this by assigning values to the free variables in the predicate and displaying instances of these assignments. So for example if one was to challenge Alloy to find an example that satisfies the predicate {\small\verb$contains.requires!=none$} (i.e. not empty) it might respond by constructing something like Figure~\ref{fig:fig1}. The free variables in this predicate are {\small\verb$contains$} and {\small\verb$requires$} so Alloy will create any instances of these whole relations that it needs to show an example or a counter-example.

In practice, one constructs much more significant challenges, such as ``in a given situation, there are no dangling-requires" and Alloy will construct a counter-example, if one exists in the finite scope that it has been allowed to search.


\section{\uppercase{Consistency and Completeness}}
\label{sec:consistency}
\noindent The Architecture Description technique that we advocate assumes that the System Engineer will specify a metamodel and record the design against that metamodel. The metamodel will comprise entities, relationships and constraints. This section describes two such metamodels, shown respectively in Figure~\ref{fig:fig3} and Figure~\ref{fig:fig4}. We develop five consistency constraints that, according to the System Engineer who designed these metamodels, are among those that need to be satisfied if the Architecture being descibed is to be consistent. We also address a notion of completeness.

We will assume that during development of the Architecture Description, interim models will not be consistent. We will discuss the reasons for this in a later section. The consequence for us here is that the constraints will be specified as sets of inconsistencies. The designer's eventual objective is to achieve a design in which these sets of inconsistencies are eliminated. This approach to design supports both incremental and cooperative working.


\subsection{Dangling Requires}

\noindent As a first example of a consistency rule, let us define the example we discussed in an earlier section, dangling-requires. Using the relations and entities illustrated in Figure~\ref{fig:fig3} we can construct the relation
\begin{small}
\begin{verbatim}
  dr = contains.requires 
         - contains.supplies 
              - requires 
\end{verbatim}
\end{small}
This defines a relation {\small\verb$dr$} which relates Components to Interfaces. The relation {\small\verb$contains.requires$} contains all pairs {\small\verb$c->i$} with the property that {\small\verb$c$} contains a Component that requires {\small\verb$i$}. Similarly {\small\verb$contains.supplies$} contains all pairs {\small\verb$c->i$} with the property that {\small\verb$c$} contains a Component that supplies {\small\verb$i$}. Thus the difference of these two relations contains all pairs where {\small\verb$c$}'s requirement for {\small\verb$i$} is not satisfied internally. 

Finally, by then constructing the difference between this set and the relation {\small\verb$requires$}, we have that {\small\verb$dr$} is the relation between Components {\small\verb$c$} and Interfaces {\small\verb$i$}, where {\small\verb$c$} contains a nested Component that requires {\small\verb$i$} but where that Interface is neither supplied internally nor required by the parent. This is exactly what we meant by dangling-requires.

Constructing the relation {\small\verb$dr$} has two benefits. First we have accepted that during development a design will be inconsistent and have taken as the responsibility to derive at any point in time a set on inconsistencies that the designer will eventually wish to remove. Second, by constructing a relation, we have taken a holistic approach, addressing the whole architecture description with our analysis rather than just looking at local inconsistencies. We will discuss the benefits of this holistic approach later. 

\subsection{Dangling Supplies}

\noindent We described informally, earlier, what we mean by dangling supplies. Formally, in terms of our metamodel we can specify this as follows
\begin{small}
\begin{verbatim}
  ds = dom(contains)<:supplies 
             - contains.supplies
\end{verbatim}
\end{small}
The operator {\small\verb$<:$} in Alloy is domain-restrict. The first term in the definition of {\small\verb$ds$} is just the relation {\small\verb$supplies$} restricted to the domain of {\small\verb$contains$} which is just the relationship between {\em composite} Components and the Interfaces they supply. By constructing the difference between this relation and {\small\verb$contains.supplies$} we get {\small\verb$ds$} which relates composite Components to Interfaces that they supply but which are not supplied by any of their children. Precisely what we meant by dangling-supplies when we introduced it informally, earlier.

\subsection{Cycles}

\noindent In Composite Structure diagrams of the sort we have shown in Figures~\ref{fig:fig1} and~\ref{fig:fig2}, it would not be sensible to find a Component nested (however deeply) in itself. We can define a {\em cycle} as any collection of Components that have the property that each is nested (indirectly) in itself as follows
\begin{small}
\begin{verbatim}
  cycles= ~^contains & contains
\end{verbatim}
\end{small}
The operators \verb$~$, \verb$^$  and \verb$&$ in Alloy are repectively transpose, transitive-closure and intersection. Thus \verb$^contains$ is the relation that relates all Components between which there is a path of contains links. Thus \verb$~^contains$ is the relation that records the ancestry, through backwards contains links, of  each  Component. So the intersection of that with {\small\verb$contains$} is the relation between Components and their children, for those Components that have their children (and consequently themselves) as ancestors. That is what we mean by cycles. If they are introduced during editing of an Architecture description, they represent an inconsistency that needs to be removed.
 
The relation {\small\verb$cycle$} will need to be empty eventually, but it is just the sort of consistency constraint that is not satisfied during the incremental development of a description, especially where that description is being developed concurrently by a number of architects.
%
\begin{figure}[!h]
  \centering
   {\epsfig{file = figures/figure4.eps, width = 7.0 cm}}
  \caption{An extended metamodel}
  \label{fig:fig4}
\end{figure}
%


\subsection{Unfulfilled Requirements}

\noindent Figure~\ref{fig:fig4} shows an extended metamodel in which we have added a new entity, a Requirement. This comes from the SysML extension to UML, where, like a Component or an Interface, a Requirement is an entity with properties including details of its meaning and its associations with other entities. Here we have shown that a Requirement can have a {\em derivedFrom} relationship with other Requirements, which is used to form a hierarchy of Requirements. Most Requirements will be derivedFrom one or more parents. Top-level Requirements will, of course, have no parents. 

We will formulate a constraint between Requirements and Components. Note that there is a relationship {\em implements} between Components and Requirements, intended to record the architectural decision that particular Components will implement particular Requirements. The consistency we wish to achieve is that, where we have a Requirement implemented by a composite Component, then the derived Requirements will be implemented by that Component's children. This is very similar to a constraint that can often be adopted by users of Telelogic DOORS.

We can formulate this constraint in many ways. The following formulation constructs a relation that determines what we will refer to as {\em unfulfilled requirements}
\begin{small}
\begin{verbatim}
  ur = implements.~derivedFrom 
              - contains.implements
\end{verbatim}
\end{small}
The term {\small\verb$implements.~derivedFrom$} relates Components to the derived Requirements that {\em should} be implemented by their children. The term {\small\verb$contains.implements$} relates Components to the Requirements that {\em are} implemented by their children. So the difference of these two terms is a relation  that relates Components to Requirements imposed upon their children, where those Requirements are as yet unimplemented. This is what we meant when  we described {\em unfulfilled requirements} informally.

\subsection{Replacements}

\noindent As a final example of a consistency constraint imposed by a metamodel on an Architecture, consider the situation when our Architecture is for an Open System, where we have potentially alternative suppliers of interchangeable Components. A system is Open if its interfaces are fully defined and available for exploitation, in that alternative suppliers can produce replacement or enhanced Components that plug into slots vacated by other components. How can we determine which Components are potential replacements for others?

Consider 
\begin{small}
\begin{verbatim}
  rep = { c1 -> c2 | 
            c2.supplies in c1.supplies 
       and  c1.requires in c2.requires} 
\end{verbatim}
\end{small}
As before, this is a binary relation. It denotes the relationship between Components with the property that if \verb$c1->c2$ is in \verb$rep$ then \verb$c2$ can replace \verb$c1$, wherever it might occur, simply because it supplies all the Interfaces that \verb$c1$ must supply and requires only Intefaces supplied in the location that \verb$c1$ would occupy.

This means that we have, in this metamodel, taken a particular view of what we mean by an Interface. An entity which represents an Interface by name, effectively encodes in that name both the syntax and semantics of the Interface. This is not unusual in practice but does leave undeveloped here how unequal, but related Interfaces, are to be handled in our metamodel. This is beyond the scope of this paper.

\subsection{Completeness}

\noindent In addition to rules for checking consistency of an architecture as it is developing, there will be many rules that specify completeness of the description. Examples of such rules for the metamodels used in this paper might be that every Component should have at least one Interface that it requires or supplies.

When constructing a constraint for completeness we will work in the same way as we have for consistency and report incompletenesses during development. For example, we might report the set of Components for which there are, as yet, no Interfaces either required or supplied.

In other systems for which we have developed metamodels, the kind of 
completeness rules we have developed include constraints such as every Component/Requirement pair should have at least one TestCase or the constraint that every entity should have at least one Documentation fragment attached to it. 

Reports generated of architectures in development would then include sections listing incompletenesses alongside those listing inconsistencies. The Architect's objective would be, eventually, to eliminate these sections.


\section{\uppercase{Pragmatic Issues}}
\label{sec:pragmatics}
\noindent We turn now to the pragmatic issues of how this method can be deployed in practice. It is normal for a Systems Engineering team, involved in a large-scale project, to have little choice over the methods and tools they deploy, so it is desirable for any new method or tool to be able to interwork with existing methods and tools.

At its simplest, the method advocated here, recommends the adoption of specific metamodels {\em within} the already adopted method of Architecture Description. The only established methods we have investigated here are UML and SysML, but these are among the most widely-used and are in many respects typical of the state of the (pragmatic) art. 

With this interoperability requirement in mind, we have developed an approach and some tools along with recommendations as to how these should be used and it is these that we address now.

\subsection{Whole Architecture Approach}
\noindent The use of relational algebra in developing the metamodels has led to a holistic approach to Architecture Description, where properties of a consistent architecture are specified in terms of the whole description at any point in time, rather than a set of local constraints upon individual entities. The effect of this is that the architects can see the consequences on the {\em whole architecture} of a change to the description or to the metamodel, as soon as that change is made. 

The holistic approach manifests itself in our formulations by always computing derived relations from the entire set of base relations in the database. At any time, the entire database will consist of all of the entities and relationships described so far. The Architect can enter new information by editing (through the use of some tool, see next subsection) base relations and then recomputing some or all of the derived relations such as {\em dangling requires}. Thus the effect of recent changes and the current proximity to consistency can be seen for the {\em whole} design at that instant.

\subsection{Tools}

\noindent We have stated that it is important in the context of Systems Engineering to support users with an investment in existing methods and tools. This we have done, as we will explain, when developing our own tools. First let us describe our tools.

We have a traditional relational database in which the Architecture Description can be stored in tables corresponding to the multi-relations defined by the adopted metamodel. From this we can extract the challenges to be presented to Alloy. The System Architect will edit the database to incrementally extend the current Description. Our tool will then present the entire database to Alloy which is used to compute all the inconsistencies that remain in the Description. These are then returned to the database (as a set of tables). The database's normal report generating functions can be used to present a report on the remaining inconsistencies.

The way such a tool integrates with conventional usage depends on context. We have worked with conventional UML/SysML tools (specifically Enterprise Architect from Sparx) which can dump the architecture description in a standard (XMI) format. This is imported to our relational database by an XSLT transformation. The consequence of this is that the user thinks of the repository of the architecture as being the ``database" within their UML tool. The path through consistency checking to inconsistencies-report is effectively a plug-in to this existing tool.

Of course, there is the need to develop (and adopt) the metamodel. Developing the metamodel is effectively a team pursuit and requires a role of meta-Architect. Interestingly, the metamodel will itself evolve during a project, and so there will be the need frequently to update the tools to reflect changes to the metamodel. The holistic approach appears to make this much easier. The formulation of constraints as whole new relations to be computed, and the fact that these derived relations can often just be ``read-off" the metamodel diagram, can mean it takes just a few minutes to change the metamodel, a feature of this approach that we consider essential.

We have worked recently with users that have developed a metamodel which captures information on UML Sequence Diagrams. The metamodel checks consistency of the use of messages. They should only go between components that are in the appropriate association with each other. Moreover, the metamodel enumerates many expected completenesses, in particular about the existence of particular fragments of documentation, so that the automatic generation of documentation is properly supported \cite{Henderson3}. 

\subsection{Collaborative Development}
\noindent Large systems are designed by teams of architects who work collaboratively. Our tools are designed to support that. Incremental editing of the Architecture Description is supported because inconsistency is tolerated. Many architects can be editing the same database at the same time without interfering with each other, simply by virue of the normal interlocks provided by a transactional database.

More interestingly, if the team is such that each member works on their own copy of the database, which will ultimately be merged (a common way of working) that doesn't prevent our tool from working across the whole architecture. Specifically, each database is imported to a combined database using a metamodel specific merge (it is seldom more than table union) and the consistency report is generated from that. This too is a consequence of the holistic approach, which manifests itself in the relational model by always computing results using whole relations. Thus users can use consistency checking across the whole architecture even though separate parts of it are under separate development

\section{\uppercase{Conclusions}}
\label{sec:conclusion}

\noindent We contend that architecture description is an important problem for Information Systems development, especially for large systems with many architects and many engineers. 

We have observed that such an architecture description is likely to be incomplete and inconsistent for much of its life. We have argued that capturing the architecture description according to a precise metamodel introduces the kind of redundancy in description that allows inconsistencies to be detected early in the life of an architecture description.

We have given examples of the kinds of metamodels that can be developed. We have described tools based on UML and Alloy that allow a pragmatic approach to developing both metamodels and architecture descriptions that are compliant to those metamodels.

In the future, we will refine our methods and tools in particular ways, not least in integrating the architecture description with its documentation based on narrative structure \cite{Henderson3}. We plan to publish detailed metamodels that we have developed along with collaborators. We recognise that many of the more complex consistency constraints that we specify have analogues in graph algorithms and wish to pursue this potentially rich theme. In particular, it might allow us to investigate the kinds of architectural complexity that Alexander described in the 60s and then deprecated in the 70s \cite{Alexander} or put more flesh on the bones of interesting new developments such as the Algebra of Systems \cite{Koo}

The method we have presented is now quite mature and is being applied in practice by our industrial collaborators. The tools are usable and integrate well with established tools, although we have plans for their further evolution that we have reported elsewhere \cite{Henderson4}. We believe that the method and tools together constitute a sound and practical method of enhancing architecture description.



%\section*{\uppercase{Acknowledgements}}
%\noindent Withheld from this version for blind refereeing process

%\noindent Daniel Jackson, MIT, WG2.3, 
%Colleagues of authors to be
% specified

\renewcommand{\baselinestretch}{0.98}
\bibliographystyle{apalike}
{\small
\bibliography{archconsist}}
\renewcommand{\baselinestretch}{1}


\end{document}
